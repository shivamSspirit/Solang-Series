---
title: Solidity Pragmas Explained
author: Shivam
moduleNumber: module-1
modulePart: module-1-b
thisFileName: pragmas
orderNumber: "7"
modulePartDescription: Learn about the role and importance of pragmas in Solidity, especially in the context of Solana programming.
---

# Objective

In this lesson, you'll:

- Gain an understanding of what pragmas are in Solidity.
- Discover why pragma versions are crucial in Solidity programming.

## Quick Summary

Pragmas in Solidity are compiler directives, often used to indicate compatible compiler versions or to enable certain compiler features. In the context of Solang, most pragma statements are ignored, as Solang doesn't enforce version matching like Ethereum Solidity.

## Detailed Overview

**What are Pragmas?**

- Pragmas are special instructions for the compiler, consisting of a name and a value.
- In Solidity, they're typically used to specify the version of the Solidity compiler that should be used.

Example:

```solidity
pragma solidity >=0.4.0 <0.4.8;
```

**Solang and Pragma Solidity:**

- Unlike the Ethereum Foundation Solidity compiler, Solang does not follow the same version numbering scheme. Thus, `pragma solidity` statements are silently ignored.
- With Solang, there's no requirement for a `pragma solidity` statement, as it views compiler versions as a part of the build environment rather than the source code.

**Pragmas in Ethereum Solidity:**

- Ethereum Solidity uses `pragma` to ensure that the compiler version matches what the contract author used.

- This approach is meant to prevent any unexpected errors due to language revisions that may make different versions of the compiler incompatible.
- The `pragma` directive in Ethereum Solidity is a means to enforce compatibility and ensure that the code behaves as expected under a specific compiler version.

**Differences in Solang's Approach:**

1. **Compatibility Across Versions**: Solang aims to maintain compatibility with various versions of Ethereum Solidity, avoiding the need for a new Solang release for each Solidity version.
2. **Multiple Blockchain Targets**: Solang targets multiple blockchains, which complicates the idea of tying the compiler version to a specific version of Solidity.
3. **Build Environment vs. Source Code**: Solang treats the compiler version as a part of the build environment, not as a property of the source code. This approach differs from other programming languages, where the source code typically doesn't dictate the compiler version
4. **Conditional Compilation**:  Rather than setting the compiler version, Solang, like some other languages, may support conditional compilation based on the compiler version, offering a more flexible approach. In summary, while `pragma` directives are an integral part of Ethereum Solidity for specifying compiler versions, Solang adopts a different approach, focusing on broader compatibility and viewing compiler versions as an aspect of the development environment rather than the source code.

Next, we'll explore various data types supported in Solidity, further enhancing your understanding of the language.